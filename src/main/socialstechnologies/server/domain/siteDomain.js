// siteDomain.js
'use strict';
var mailService = require('../config/mail');
var express = require('express');
var mongoose = require('mongoose');
var nodemailer = require('nodemailer');
var model = require('../model/socialstechnologies');
var util = require('../shared/util');
var securityDomain = require('./securityDomain');

let mailTransporter = nodemailer.createTransport(mailService.sst);

// Profile Elevation
function generateElevationRequest(
	userId,
	requestInformation,
	elevationRequestContact) {
	return new Promise(function (resolve, reject) {

		if (!userId) {
			var error = util.error.invalidRequest({
				code: util.constants.error.data,
				description: 'Error at Generate Elevation Request [generateElevationRequest]. The user identifier of the request\'s originator [userId] is required.'
			});
			reject(error);
			return;
		}

		if (!requestInformation ||
			!requestInformation.details ||
			requestInformation.details.length == 0) {
			var error = util.error.invalidRequest({
				code: util.constants.error.data,
				description: 'Error at Generate Elevation Request [generateElevationRequest]. The requets\'s details [requestInformation.details] are required and cannot be empty.'
			});
			reject(error);
			return;
		}

		if (!elevationRequestContact) {
			var error = util.error.invalidRequest({
				code: util.constants.error.data,
				description: 'Error at Generate Elevation Request [generateElevationRequest]. The contact information of the request\'s originator [elevationRequestContact] is required.'
			});
			reject(error);
			return;
		}

		var contactDescription =
			'Name: ' + elevationRequestContact.fullName + '\n' +
			'Email: ' + elevationRequestContact.email + '\n' +
			'Phone: ' + elevationRequestContact.phones.mobile + '\n';

		submitRequest(util.constants.request.types.elevation, {
			from: userId,
			category: 'Accounts',
			subcategory: 'Elevations',
			createdBy: {
				_id: userId,
				on: Date()
			},
			details: [
				requestInformation.details[0], {
					title: 'Elevation Request generated',
					details: 'Elevation request was generated by user [' + userId + ']:\n' + contactDescription,
					date: Date()
				}
			]
		}).then(request => {
			console.log('Elevation request registered.');
			resolve(request);
			return;
		}).catch(err => {
			reject(err);
			return;
		});
	});
}

function sendElevationApproverMail(
	profileElevationAPIUrl,
	elevationRequest,
	elevationRequestContact) {
	return new Promise(function (resolve, reject) {
		if (!profileElevationAPIUrl) {
			var error = util.error.invalidRequest({
				code: util.constants.error.data,
				description: 'Error at Send Elevation Approver Mail[sendElevationApproverMail]. The Profile Elevation API URL [profileElevationAPIUrl] is required.'
			});
			reject(error);
			return;
		}

		if (!elevationRequest) {
			var error = util.error.invalidRequest({
				code: util.constants.error.data,
				description: 'Error at Send Elevation Approver Mail[sendElevationApproverMail]. The information of the elevation request [elevationRequest] is required.'
			});
			reject(error);
			return;
		}

		if (!elevationRequestContact) {
			var error = util.error.invalidRequest({
				code: util.constants.error.data,
				description: 'Error at Send Elevation Approver Mail[sendElevationApproverMail]. The contact information of the elevation request\'s generator [elevationRequestContact] is required.'
			});
			reject(error);
			return;
		}

		var elevationApproverEmail = util.constants.security.profileElevation.approverMail;
		var elevationLink = profileElevationAPIUrl + '/' + elevationRequest._id;
		var text = 'The user with id [' + elevationRequest.from +
			'] has submitted a profile elevation request.\n' +
			'Name: ' + elevationRequestContact.fullName + '\n' +
			'Email: ' + elevationRequestContact.email + '\n' +
			'Mobile Phone: ' + elevationRequestContact.phones.mobile + '\n' +
			'Please click the fallowing link to finish the activation process: ' + elevationLink

		var mail = {
			to: elevationApproverEmail,
			subject: 'Account Elevation - From: ' + elevationRequestContact.fullName + '|' + elevationRequestContact.email,
			text: text,
			createdBy: {
				_id: util.constants.appUser
			}
		}

		sendMail(mail)
			.then(registeredMail => {
				console.log('Elevation Approver\'s mail sended.');
				resolve(registeredMail);
				return;
			}).catch(err => {
				reject(err);
				return;
			});
	});
}

function updateElevationRequest(
	action,
	originalRequest,
	approverUserId
) {
	return new Promise(function (resolve, reject) {
		if (!action) {
			var error = util.error.invalidRequest({
				code: util.constants.error.data,
				description: 'Error at Update Elevation Request[updateElevationRequest]. The action [action] is required.'
			});
			reject(error);
			return;
		}
		if (!originalRequest) {
			var error = util.error.invalidRequest({
				code: util.constants.error.data,
				description: 'Error at Update Elevation Request[updateElevationRequest]. The original request information [originalRequest] is required.'
			});
			reject(error);
			return;
		}
		if (!approverUserId) {
			var error = util.error.invalidRequest({
				code: util.constants.error.data,
				description: 'Error at Update Elevation Request[updateElevationRequest]. The approver\'s identifier [approverUserId] is required.'
			});
			reject(error);
			return;
		}

		var approvalAction = util.constants.security.profileElevation.actions.approve;

		var fulfilledStatus = util.constants.request.fulfillmentStatus;

		originalRequest.status = fulfilledStatus;
		originalRequest.modifiedBy = {
			_id: approverUserId,
			on: Date()
		}

		var detail = {}

		if (action === approvalAction) {
			detail.title = 'Elevation Request Approved';
			detail.details = 'Elevation Request was approved by site admin.';
			detail.date = Date();
		} else {
			detail.title = 'Elevation Request Rejected';
			detail.details = 'Elevation Request was rejected by site admin.';
			detail.date = Date();
		}

		// Register request fulfillment details.
		originalRequest.details.push(detail);

		updateRequest(
			originalRequest._id,
			originalRequest
		).then(updatedElevationRequest => {
			console.log('Elevation request updated with action ' + action);
			resolve(updatedElevationRequest);
			return;
		}).catch(err => {
			reject(err);
			return;
		})
	})


}

function sendElevationProcessedMail(
	elevationRequestContact,
	elevationRequestResult
) {
	return new Promise(function (resolve, reject) {
		if (!elevationRequestContact) {
			var error = util.error.invalidRequest({
				code: util.constants.error.data,
				description: 'Error at Send elevation request processed mail [sendElevationProcessedMail]. The contact information of the elevation request\'s originator [elevationRequestContact] is required.'
			});
			reject(error);
			return;
		}

		if (!elevationRequestResult) {
			var error = util.error.invalidRequest({
				code: util.constants.error.data,
				description: 'Error at Send elevation request processed mail [sendElevationProcessedMail]. The elevation request\'s result [elevationRequestResult] is required.'
			});
			reject(error);
			return;
		}

		var text = 'Hello ' + elevationRequestContact.fullName + ', Your elevation request was ' + elevationRequestResult + '.';
		var mail = {
			to: elevationRequestContact.email,
			subject: 'Account Elevation - Elevation Result',
			text: text,
			createdBy: {
				_id: util.constants.appUser
			}
		}

		sendMail(mail)
			.then(registeredMail => {
				console.log('Elevation request processed mail sended');
				resolve(registeredMail);
				return;
			}).catch(err => {
				reject(err);
				return;
			})
	});



}

// Activation

function activateAccountWithRequest(requestId) {
	return new Promise(function (resolve, reject) {
		if (!requestId) {
			var error = util.error.invalidRequest({
				code: util.constants.error.data,
				description: 'Error at Activate Account with Request[activateAccountWithRequest]. The request identifier [requestId] is required.'
			});
			reject(error);
			return;
		}

		var activationRequest = {
			details: [{
				title: 'Activation Request Processed',
				details: 'Activation Request fulfilled after user confirmation.',
				date: Date()
			}],
			status: util.constants.request.fulfillmentStatus,
			modifiedBy: {
				_id: util.constants.appUser
			}
		}

		updateRequest(
				requestId,
				activationRequest
			).then(result => {
				console.log('Activation request updated.');
				return securityDomain.user.update(
					result.from,
					true,
					true, ['user'], {
						_id: result.from
					}
				);
			}).then(updatedUser => {
				console.log('User Activated.');
				resolve(updatedUser);
				return;
			})
			.catch(err => {
				reject(err);
				return;
			})

	})
}

function sendUserActivationMail(activationAPIUrl, user_id, emailAddress) {
	return new Promise(function (resolve, reject) {
		securityDomain.user.findById(user_id)
			.then((user) => {
				if (user) {
					return generateActivationRequest(user._id);
				} else {
					var error = util.error.invalidRequest({
						code: util.constants.error.data,
						description: 'Error ar Send User Activation Mail [sendUserActivationMail]. User not found.'
					})
					reject(error);
					return;
				}
			}).then(activationRequest => {
				var activationLink = activationAPIUrl + '/' + activationRequest._id;

				var mail = {
					to: emailAddress,
					subject: 'Account Activation - Welcome to Social Solution Technologies',
					text: 'Thank you for join us. Please click the fallowing link to finish the activation process: ' + activationLink,
					createdBy: {
						_id: util.constants.appUser
					}
				}
				return sendMail(mail);
			}).then(mail => {
				console.log('User Activation mail delivered.')
				resolve(mail);
			}).catch(err => {
				reject(err);
				return;
			})
	});

}

function generateActivationRequest(userId) {
	return new Promise(function (resolve, reject) {
		submitRequest(util.constants.request.types.activation, {
				from: userId,
				category: 'Accounts',
				subcategory: 'Activations',
				createdBy: {
					_id: util.constants.appUser
				}
			})
			.then(activationRequest => {
				console.log('Activation Request registered');
				resolve(activationRequest);
				return;
			}).catch((err) => {
				reject(err);
				return;
			})
	})

}

// CRUD

// Requests
function updateRequest(requestId, request) {

	var invalidRequestStates = util.constants.request.invalidUpdateStatus;

	return new Promise(function (resolve, reject) {

		if (!requestId) {
			var error = util.error.invalidRequest({
				code: util.constants.error.data,
				description: 'Error at Submit Request [submitRequest]. The request identifier [requestId] is required.'
			});
			reject(error);
			return;
		}

		if (!request) {
			var error = util.error.invalidRequest({
				code: util.constants.error.data,
				description: 'Error at Submit Request [submitRequest]. The request information [request] is required.'
			});
			reject(error);
			return;
		}

		if (!request.modifiedBy) {
			var error = util.error.invalidRequest({
				code: util.constants.error.data,
				description: 'Error at Submit Request [submitRequest]. The request modifier information [request.modifiedBy] is required.'
			});
			reject(error);
			return;
		}

		model.request.findOne({
			_id: requestId,
			status: {
				$nin: invalidRequestStates
			}
		}, function (err, retrievedRequest) {
			if (!err) {

				if (retrievedRequest) {
					retrievedRequest.status = request.status;
					retrievedRequest.details = request.details;
					retrievedRequest.modifiedBy = {
						_id: request.modifiedBy._id,
						on: Date()
					}
					return retrievedRequest.save()
						.then(updatedRequest => {
							resolve(updatedRequest);
							return;
						}, err => {
							var error = util.error.api(err, {
								code: util.constants.error.persistance,
								description: 'Error at Update Request [updateRequest].'
							})
							reject(error);
							return;
						})
				} else {
					var error = util.error.invalidRequest({
						code: util.constants.error.data,
						description: 'Request not found.'
					})
					reject(error);
					return;
				}
			} else {
				var error = util.error.api(err, {
					code: util.constants.error.persistance,
					description: 'Error at Update Request [updateRequest].'
				})
				reject(error);
				return;
			}
		})
	})
}

function submitRequest(type, request) {
	return new Promise(function (resolve, reject) {

		if (!type) {
			var error = util.error.invalidRequest({
				code: util.constants.error.data,
				description: 'Error at Submit Request [submitRequest]. The request type [type] is required.'
			});
			reject(error);
			return;
		}

		if (!request) {
			var error = util.error.invalidRequest({
				code: util.constants.error.data,
				description: 'Error at Submit Request [submitRequest]. The request information [request] is required.'
			});
			reject(error);
			return;
		}

		if (!request.createdBy) {
			var error = util.error.invalidRequest({
				code: util.constants.error.data,
				description: 'Error at Submit Request [submitRequest]. The request creator information [request.createdBy] is required.'
			});
			reject(error);
			return;
		}

		var newRequest = model.request({
			_id: mongoose.Types.ObjectId(),
			type: type,
			from: request.from,
			details: request.details,
			status: util.constants.request.defaultStatus,
			createdBy: {
				_id: request.createdBy._id,
				on: Date()
			},
			category: request.category,
			subcategory: request.subcategory
		});

		return newRequest.save()
			.then(registeredRequest => {
				console.log('Request registered.');
				resolve(registeredRequest);
				return;

			}, err => {
				var error = util.error.api(err, {
					code: util.constants.error.persistance,
					description: 'Error at Submit Request [submitRequest].'
				})
				reject(err);
				return;
			})
	});
}

function findRequestById(requestId) {
	return new Promise(function (resolve, reject) {
		model.request.findOne({
			_id: requestId
		}, function (err, retrievedRequest) {
			if (!err) {
				console.log('Request retrieved.');
				resolve(retrievedRequest);
			} else {
				var error = util.error.api(err, {
					code: util.constants.error.persistance,
					description: 'Error at fin request by identifier [findRequestById].'
				})
				reject(error);
			}
			return;
		})
	});
}

// Mails

function readMails(period, filter) {
	return new Promise(function (resolve, reject) {
		model.mail.find(filter,
			function (err, retrievedRequest) {
				if (!err) {
					console.log('Mails retrieved.');
					resolve(retrievedRequest);
				} else {
					var error = util.error.api(err, {
						code: util.constants.error.persistance,
						details: 'Error at read mails.'
					})
					reject(error);
				}
				return;
			});
	});
}

function sendMail(mail) {
	return new Promise(function (resolve, reject) {

		if (!mail) {
			var error = util.error.invalidRequest({
				code: util.constants.error.data,
				description: 'Error at send Mail [sendMail]. Mail information [mail] is required.'
			});
			reject(error);
			return;
		}

		if (!mail.createdBy) {
			var error = util.error.invalidRequest({
				code: util.constants.error.data,
				description: 'Error at send Mail [sendMail]. Mail creator information [createdBy] is required.'
			});
			reject(error);
			return;
		}

		var newMail = model.mail({
			_id: mongoose.Types.ObjectId(),
			createdBy: {
				_id: mail.createdBy._id,
				on: Date()
			},
			status: util.constants.mail.initialStatus,
			from: util.constants.mail.sender,
			to: mail.to,
			subject: mail.subject,
			text: mail.text,
			html: mail.html,
			service: mailService.host
		});

		newMail.save()
			.then(registeredMail => {
				var mailBody = {
					from: registeredMail.from,
					to: registeredMail.to,
					subject: registeredMail.subject,
					text: registeredMail.text
				}

				mailTransporter.sendMail(mailBody, (err, result) => {
					if (!err) {
						registeredMail.status = 'delivered';
						registeredMail.modifiedBy = {
							_id: mail.createdBy._id,
							on: Date()
						}
						registeredMail.save()
							.then(updatedMail => {
								console.log('Mail delivered.');
								resolve(updatedMail);
								return;
							}, err => {
								var error = util.error.api(err, {
									code: util.constants.error.persistance,
									description: 'Error at send mail [sendMail]. Mail was delivered but its status couldn\'t be updated.'
								});
								reject(error);
								return;
							})
					} else {

						var error = util.error.api(err, {
							code: util.constants.error.externalProvider,
							description: 'Error at send mail. Cannot send mail with the current transport settings.'
						});

						registeredMail.status = util.constants.mail.failureStatus;
						registeredMail.modifiedBy = {
							_id: util.constants.appUser,
							on: Date()
						}
						registeredMail.error = err;

						registeredMail.save()
							.then(updatedMail => {
								reject(error);
								return;
							}, err => {
								var error = util.error.api(err, {
									code: util.constants.error.persistance,
									description: 'Error at send mail. Cannot send mail with the current transport settings. There were additional failures in updating mail status.'
								});
								reject(error);
								return;
							});
					}
				})
			}, err => {
				var error = util.error.api(err, {
					code: util.constants.error.persistance,
					description: 'Error at send mail.'
				})
				reject(error);
				return;
			})
	})
}


// Contents

function readSSTContents(name) {
	return new Promise(function (resolve, reject) {

		if (!name) {
			var error = util.error.invalidRequest({
				code: util.constants.error.data,
				description: 'Error at read SST Contents [readSSTContents]. The content name [name] is required.'
			});
			reject(error);
			return;
		}

		model.content.findOne({
			name: name
		}, function (err, retrievedContent) {
			if (!err) {
				if (retrievedContent) {
					console.log('SST Contents retrieved.');
					resolve(retrievedContent);
					return
				} else {
					var error = util.error.generic(400, {
						code: util.constants.error.data,
						description: 'No Contents found with the name ' + name
					});
					reject(error)
					return;
				}
			} else {

				var error = util.error.api(err, {
					code: util.constants.error.persistance,
					description: 'Error at read SST Contents [readSSTContents].'
				});
				reject(error);
				return;
			}
		});



		/*
		try{
			var content = {
				items: [
					{
						imageUrl:'/client/resources/img/IMG_3240.JPG'
						,minHeight:"20em"
						,title:'Capabilities'
						,subtitle:'Solutions with Social Impact'
						,details:[
							{
								imageUrl:'http://www4.pictures.lonny.com/lo/rQ7V5XzYyCXl.jpg',
								text:'<p>Go social</p><span>As with many people, We wonder why, in modern times like these, social issues can\'t be addressed effectively. People around the world is becoming aware of the benefits of technology in areas such as <b>Healthcare</b>, <b>Logistics</b>, <b>Democracy</b>, among others. This is the time to leverage technology development upon our society. With everyone\'s commitment and dedication, technology will enhance the impact of local initiatives to support community\'s predicaments.</span><hr>'
							},
							{
								imageUrl:'http://www4.pictures.lonny.com/lo/rQ7V5XzYyCXl.jpg',
								text:'<p>Go mobile</p><span>Mobile Solutions are the beginning of the journey. We\'re aware of the multiple opportunities offered by mobile technologies, such as <b>efficiency</b>, <b>immediacy</b>, and <b>portability</b>. Additionally, because of mobile technologies capabilities, new forms of information have emerged and changed the way we learn. By using creativity these new forms of information provide <b>valuable knowledge</b>; a knowledge that can escalate the business impact. So, we\'ve focused our initial efforts in the mastering of core technologies enduring mobile solutions:<br><br><ul><li>Mobile Sensors</li><li>Embedded Persitence Mechanisms</li><li>Web APIs</li><li>Geolocation</li><li>Social Networks</li><li>OAUTH</li></ul></span><hr>'
							}
						]
					},
					{
						imageUrl:'/client/resources/img/IMG_3207.JPG'
						,minHeight:"20em"
						,subtitle:'In Social S Technologies...'
						,title:'What the S stands for?'
						,details:[
							{ 
								imageUrl:'/client/resources/img/socialstechnologies-s.PNG',
								text:'<p><strong>\'S\'</strong> Stands for <b>S</b>ustainability</p><span>It is not a secret we\'re in the middle of a technologic revolution. At the same time, we are the witness of concerning social issues that affect our community. If the industry found out innovative ways to get benefits from technology, why cannot society?.<br><br>It is required to find a way to ease people\'s helping people, to spot for innovative ways of supporting charities and non-profit initiatives through technology. <b>Mobility</b>, <b>Artificial Intelligence (AI)</b>, <b>Internet of Things (IoT)</b>, among other technologies, are emerging to make the future a reality. <br><br>Our motivation is finding a way to offer <b>Sustaibable solutions</b> for communities, people, and local business. We pursue a model that would address global problems such as <b>Homelessness</b>, <b>Poverty</b>, <b>Undernourishment</b>, <b>Unemployment</b>, <b>Healthcare</b> and so on. It can be achieved by the relying on simple but robust technologic solutions; solutions that will assist people in solving everyday problems of the community.<br><br>There are a bunch of application scenarios. <br><br><b>So, let\'s make it real TOGETHER!</b></span><hr/>' 
							}
							, { 
								imageUrl:'/client/resources/img/IMG_3222.JPG',
								text:'<p><strong>\'S\'</strong> Stands for <b>S</b>trategy</p><span>Technology is a powerful tool for business, but it isn\'t a competitive advantage by itself anymore. By applying <b>ITILÂ®</b> framework practices, we start by understanding your business goals, objectives, and strategy, such a way together we can identify the technologies that better fit your expectations and capabilities, and align them to your strategy. Your business is not technology focused. So, you shouldn\'t invest in pure technology but technologic solutions.</span><hr/>'
							}
							, { 
								imageUrl:'/client/resources/img/IMG_3218.JPG',
								text:'<p><strong>\'S\'</strong> Stands for <b>S</b>olutions</p><span>Because of cost and intrinsic complexity, technology in small businesses happens to be frightening. However, we\'re used to enjoying of benefits of Technology in our everyday life. Solutions thinking is the key to attaining it. We believe that cutting edge technologies are there not only to address complex business environments but also enhance your business everyday problems by solutions tailored to your needs and expectations; just like in your daily life.</span><br/><br/><span><b>AI</b>, <b>IoT</b> and <b>Mobility</b> are there to make it easier than ever. Besides, because of the <b>Cloud Computing</b>, it hasn\'t to be as expensive as a few years ago. That\'s our <b>Solutions</b> thinking, the integration of technologies into specific approaches to make your business better and simpler.</span><hr/>'
							}
							, { 
								imageUrl:'/client/resources/img/IMG_3197.JPG',
								text:'<p><strong>\'S\'</strong> Stands for <b>S</b>implicity</p><span>The simpler, the better. As simple as it sounds. The simplicity of a solution makes it maintainable and <b>Scalable</b>. While looking for simplicity, We assess how technologies can get simpler your business activities, and then, which is the <b>Simplest Solution</b> that fits your needs and expectations.</span><hr/>'
							}
							, { 
								imageUrl:'https://s-media-cache-ak0.pinimg.com/564x/8e/03/8c/8e038c69f35d96d2777396ef1ed77a65.jpg',
								text:'<p><strong>\'S\'</strong> Stands for <b>S</b>calability</p><span>Scalability is the capability of technologic solutions to commensurate your business growth.  Thereby keeping all simple, it is possible to reduce the risk of incompatibilities within the business know-how and business tools. If technologic solutions are simple and standardized, the natural evolution of business is feasible. In Social Solution Technologies, we look for robust, scalable solutions that enable the <b>Business renovation and expansion</b>.</span><hr/>'
							}
						]
					},
					{
						imageUrl:'/client/resources/img/IMG_3214.JPG'
						,minHeight:"20em"
						,title:'This is the title #1'
						,subtitle:'This is the subtitle #1'
						,details:[{imageUrl:'http://www4.pictures.lonny.com/lo/rQ7V5XzYyCXl.jpg',text:'Today is a great day. Today is a great day. Today is a great day. Today is a great day. Today is a great day.'}]
					}
					
				]
			}
			resolve(content)
		} catch (ex){
			console.log(ex)
			reject(generateAPIError(ex))
		}*/
	})
}

function setSSTContent(content) {
	return new Promise(function (resolve, reject) {
		if (!content) {
			var error = util.error.invalidRequest({
				code: util.constants.error.data,
				description: 'Error at set content [setSSTContent]. Content information [content] is required.'
			});
			reject(error);
			return;
		}

		if (!content.modifiedBy) {
			var error = util.error.invalidRequest({
				code: util.constants.error.data,
				description: 'Error at set content [setSSTContent]. Content modifier information [content.modifiedBy] is required.'
			});
			reject(error);
			return;
		}

		if (!content.items ||
			content.items.length == 0) {
			var error = util.error.invalidRequest({
				code: util.constants.error.data,
				description: 'Error at set content [setSSTContent]. Content items information [content.items] is required and cannot be empty.'
			});
			reject(error);
			return;
		}

		model.content.findOne({
			name: content.name
		}, function (err, retrievedContent) {
			if (!err) {
				if (retrievedContent) {
					if (!content.modifiedBy) {
						var error = util.error.invalidRequest({
							code: util.constants.error.data,
							description: 'Error at set content [setSSTContent]. Content modifier information [content.modifiedBy] is required.'
						});
						reject(error);
						return;
					}

					retrievedContent.items = content.items;
					retrievedContent.modifiedBy = {
						_id: content.modifiedBy._id,
						on: Date()
					};

					return retrievedContent.save()
						.then(updatedContent => {
							console.log('Content Updated.')
							resolve(updatedContent);
							return;
						}, err => {
							var error = util.error.api(err, {
								code: util.constants.error.persistance,
								description: 'Error at Updater SST Content [setSSTContent].'
							})
							reject(error);
							return;
						})
				} else {
					if (!content.createdBy) {
						var error = util.error.invalidRequest({
							code: util.constants.error.data,
							description: 'Error at set content [setSSTContent]. Content creator information [content.createdBy] is required.'
						});
						reject(error);
						return;
					}

					var newContent = model.content({
						_id: mongoose.Types.ObjectId(),
						createdBy: {
							_id: content.createdBy._id,
							on: Date()
						},
						name: content.name,
						isActive: true,
						items: [{
							imageUrl: '',
							minHeight: '10em',
							title: '',
							subtitle: '',
							details: [{
								text: '',
								imageUrl: ''
							}]
						}]
					})

					return newContent.save()
						.then(registeredContent => {
							console.log('Content registered.')
							resolve(registeredContent);
							return;
						}, err => {
							var error = util.error.api(err, {
								code: util.constants.error.persistance,
								description: 'Error at Register SST Content [setSSTContent].'
							})
							reject(error);
							return;
						})
				}
			} else {
				var error = util.error.api(err, {
					code: util.constants.error.persistance,
					description: 'Error at SST Content [setSSTContent].'
				})
				reject(error);
				return;
			}
		})
	})
}

// Interactions

function createInteraction(interaction) {

	return new Promise(function (resolve, reject) {
		if (!interaction) {
			var error = util.error.invalidRequest({
				code: util.constants.error.data,
				description: 'Error at create interaction [createInteraction]. Interaction information [interaction] is required.'
			});
			reject(error);
			return;
		}

		var newInteraction = model.interaction({
			_id: mongoose.Types.ObjectId(),
			createdBy: {
				customer: {
					name: interaction.name,
					email: interaction.email
				},
				on: Date()
			},
			subject: interaction.subject,
			type: 'ContactRequest',
			details: interaction.details,
			status: 'Created'
		});

		return newInteraction.save()
			.then(registeredInteraction => {
				resolve(registeredInteraction);
				return;
			}, err => {
				var error = util.error.api(err, {
					code: util.constants.error.persistance,
					description: 'Error at create interaction [createInteraction].'
				})
				reject(error);
				return;
			})
	})
}

module.exports = {
	profileElevation: {
		request: generateElevationRequest,
		nofityRequest: sendElevationApproverMail,
		processRequest: updateElevationRequest,
		notifyRequestProcess: sendElevationProcessedMail
	},
	activation: {
		activate: activateAccountWithRequest,
		sendMail: sendUserActivationMail
	},
	interaction: {
		new: createInteraction
	},
	content: {
		read: readSSTContents,
		set: setSSTContent
	},
	mail: {
		read: readMails,
		send: sendMail
	},
	request: {
		submit: submitRequest,
		findById: findRequestById,
		update: updateRequest
	}
}